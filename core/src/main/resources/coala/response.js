// Generated by CoffeeScript 1.3.3
(function() {
  var ObjectMapper, SimpleBeanPropertyFilter, SimpleFilterProvider, buildObjectMapper, charset, getContentType, log, objects, res, type, _ref, _ref1,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  res = require('ringo/jsgi/response');

  log = require('ringo/logging').getLogger(module.id);

  _ref = require('coala/util'), objects = _ref.objects, type = _ref.type;

  ObjectMapper = org.codehaus.jackson.map.ObjectMapper;

  _ref1 = org.codehaus.jackson.map.ser.impl, SimpleFilterProvider = _ref1.SimpleFilterProvider, SimpleBeanPropertyFilter = _ref1.SimpleBeanPropertyFilter;

  charset = 'utf-8';

  getContentType = function(type) {
    return {
      'Content-Type': charset ? "" + type + "; charset=" + charset : type
    };
  };

  exports.charset = function(c) {
    return charset = c;
  };

  exports.redirect = res.redirect;

  exports.html = function() {
    var args, config, name, result;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = {
      status: 200,
      headers: getContentType('text/html'),
      body: args
    };
    if (args.length === 1 && type(args[0]) === 'object') {
      config = args[0];
      for (name in result) {
        if (config[name]) {
          result[name] = config[name];
        }
      }
    }
    if (type(result.body) !== 'array') {
      result.body = [result.body];
    }
    return result;
  };

  exports.xml = function() {
    var args, name, result;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = {
      status: 200,
      headers: getContentType('application/xml'),
      body: args
    };
    if (args.length === 1) {
      if (typeof args[0] === 'xml') {
        result.body = args[0].toXmlString();
      } else if (type(args[0]) === 'object') {
        for (name in result) {
          if (args[0][name]) {
            result[name] = args[0][name];
          }
        }
      }
    }
    if (type(result.body) !== 'array') {
      result.body = [result.body];
    }
    return result;
  };

  exports.notFound = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return {
      status: 404,
      headers: getContentType('text/html'),
      body: args
    };
  };

  exports.error = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return {
      status: 500,
      headers: getContentType('text/html'),
      body: args
    };
  };

  /*
  generate json response, support three ways:
  
  the first, filters configurated by a config object
  response.json(object,{
      include: {
          filter1: ['field1','field2'],
          filter2: 'field3'
      },
      exclude: {
          filter3: ['field4','field5'],
          filter4:'field6'
      }
  });
  
  the second, chained include/exclude method.
  response.json(object)
      .include('filter1',['field1','field2']).include('filter2','field3')
      .exclude('filter3',['field4','field5']).exclude('filter4','field6');
  
  the third, chained add method, use the third argument to identify include(default) or exclude( value:'exclude','e')
  response.json(object)
      .add('filter1',['field1','field2']).add('filter2','field3')
      .add('filter3',['field4','field5'],'exclude').add('filter4','field6','e');
  */


  exports.json = function(object, config) {
    var contentType, k, result, v, _ref2, _ref3;
    contentType = 'application/json';
    if (res.charset()) {
      contentType = "" + contentType + "; charset=" + (res.charset());
    }
    result = {
      _object: object,
      _included: {},
      _excluded: {},
      _jsonResult: null,
      _isStream: false,
      status: 200,
      headers: {
        'Content-Type': contentType
      },
      add: function(filter, fields, t) {
        var filters, target;
        target = t === 'e' || t === 'exclude' ? this._excluded : this._included;
        fields = Array.isArray(fields) ? fields : [fields];
        filters = target[filter];
        target[filter] = filters ? filters.concat(filelds) : fields;
        return this;
      },
      include: function(filter, fields) {
        return this.add(filter, fields, 'include');
      },
      exclude: function(filter, fields) {
        return this.add(filter, fields, 'exclude');
      },
      forEach: function(fn) {
        var mapper;
        if (this._isStream === true) {
          return;
        }
        if (this._jsonResult == null) {
          mapper = buildObjectMapper(this._included, this._excluded);
          this._jsonResult = mapper.writeValueAsString(this._object);
          log.debug("generate json, json result:" + this._jsonResult);
        }
        log.debug("forEach called, json result:" + this._jsonResult);
        return fn(this._jsonResult);
      },
      asStream: function(request) {
        var _this = this;
        this._isStream = true;
        log.debug(JSON.stringify(this.headers));
        return exports.stream(request, {
          headers: this.headers,
          status: this.status,
          body: function(stream) {
            var mapper;
            mapper = buildObjectMapper(_this._included, _this._excluded);
            mapper.writeValue(stream, _this._object);
          }
        });
      }
    };
    if (config != null) {
      _ref2 = config.include;
      for (k in _ref2) {
        v = _ref2[k];
        result.include(k, v);
      }
      _ref3 = config.exclude;
      for (k in _ref3) {
        v = _ref3[k];
        result.exclude(k, v);
      }
      result.status = config.status || result.status;
      result.headers = objects.extend(result.headers, config.headers || {});
    }
    result.body = result;
    return result;
  };

  buildObjectMapper = function(included, excluded) {
    var filter, k, mapper, v;
    filter = new SimpleFilterProvider();
    for (k in included) {
      v = included[k];
      if (__indexOf.call(excluded, k) >= 0) {
        throw new Error("filter:" + key + " have both include and exclude property");
      }
      filter.addFilter(k, SimpleBeanPropertyFilter.filterOutAllExcept(v));
    }
    for (k in excluded) {
      v = excluded[k];
      filter.addFilter(k, SimpleBeanPropertyFilter.serializeAllExcept(v));
    }
    mapper = new ObjectMapper();
    return mapper.writer(filter);
  };

  exports.stream = function(request, callback) {
    var headers, key, n, servletResponse, status, value, _i, _len;
    if (!((request != null) && (request.env != null) && (type(callback) === 'function' || type(callback) === 'object'))) {
      throw new Error('invalid arguments');
    }
    status = 200;
    headers = {
      'Content-Type': 'binary/octet-stream'
    };
    log.debug("callback: " + (JSON.stringify(callback)));
    if (type(callback) === 'object') {
      status = callback.status || status;
      headers = objects.extend(headers, callback.headers || {});
      callback = type(callback.body) === 'function' ? callback.body : function() {};
    }
    servletResponse = request.env.servletResponse;
    servletResponse.setStatus(status);
    for (key in headers) {
      value = headers[key];
      if (type(value) === 'string') {
        value = value.split('\n');
      }
      if (!Array.isArray(value)) {
        return;
      }
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        n = value[_i];
        servletResponse.addHeader(key, n);
      }
    }
    try {
      callback(servletResponse.getOutputStream());
    } catch (error) {
      return exports.error(error);
    }
    return {
      status: status,
      headers: {
        'X-JSGI-Skip-Response': true
      },
      body: []
    };
  };

}).call(this);
