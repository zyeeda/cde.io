// Generated by CoffeeScript 1.3.3

/*
# this module aims to support java-annotation-like features
# just like this:
# app.get(mark('services',['someservice','anotherservice']).on(function(){}));
#
# if annotation handler want pass arguments to function must use prepend
# the execution of annotations if first-mark-last-run
# the sequence of arguments which passed by handlers is first-mark-first-get
# mark('a').mark('b').mark('c').on(function(a, b, c){})
# execute sequence is c -> b ->a
# arguments sequence is a, b, c
*/


(function() {
  var Context, handlers, loadExtraHandler, name, obj, objects, type, _, _ref,
    __slice = [].slice;

  Context = com.zyeeda.framework.web.SpringAwareJsgiServlet.Context;

  _ref = require('coala/util'), objects = _ref.objects, type = _ref.type;

  _ = require('underscore');

  handlers = {
    tx: require('coala/marker/tx').handler,
    beans: require('coala/marker/beans').handler,
    services: require('coala/marker/services').handler,
    managers: require('coala/marker/managers').handler,
    process: require('coala/marker/process').handler
  };

  loadExtraHandler = function(moduleId) {
    var m;
    try {
      m = require(moduleId);
      if (!m.handler) {
        throw new Error("marker extension module:" + moduleId + " has no exports named handler");
      }
      if (!type(m.handler === 'function')) {
        throw new Error("marker extension module:" + moduleId + " has export a handler which is not a function");
      }
      return m.handler;
    } catch (e) {
      throw new Error("marker extension module:" + moduleId + " is not found");
    }
  };

  obj = {
    annos: [],
    keys: [],
    /*
        # parameter name is the annotation's name, it is used to find the annotation handler
        # parameter attributes will pass into the handler which is found by name
    */

    mark: function() {
      var attr, attributes, name;
      name = arguments[0], attributes = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (obj.keys.indexOf(name) !== -1) {
        throw new Error('one annotation once');
      }
      if (!(name in handlers)) {
        throw new Error("annotation " + name + " is not supported");
      }
      attr = _.flatten(attributes);
      obj.annos.push({
        attributes: attr,
        name: name
      });
      obj.keys.push(name);
      return obj;
    },
    /*
        # the end of the at chain, returns an function which wrapped the argument fn
    */

    on: function(fn, me) {
      var anno, context, result;
      result = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = obj.annos;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          anno = _ref1[_i];
          _results.push(anno);
        }
        return _results;
      })();
      obj.annos = [];
      obj.keys = [];
      context = Context.getInstance(module);
      return result.reduce((function(memo, anno) {
        var attributes, handler;
        handler = handlers[anno.name] || loadExtraHandler(anno.name);
        attributes = anno.attributes;
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return handler.apply(null, [context, attributes, memo, args]);
        };
      }), fn.bind(me));
    }
  };

  exports.mark = obj.mark;

  for (name in handlers) {
    exports[name] = obj.mark.bind(obj, name);
  }

}).call(this);
